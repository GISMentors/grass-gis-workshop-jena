Unit 10 - Python intro
======================

:wikipedia:`Python <Python (programming language)>` programming
language is very popular in the field of GIS and data science in
general. Python is also the main scripting platform for Esri products
(see `arcpy
<http://pro.arcgis.com/en/pro-app/arcpy/get-started/what-is-arcpy-.htm>`__
package). GRASS is not an exception. In reality, many GRASS modules
are basically Python scripts, eg. :grasscmd:`r.mask` (see *Source
Code* section).

GRASS Python environment consists various libraries, see
:grasscmd2:`GRASS documentation <libpython/index.html>` for
details. Let's focus on three main libraries related to this workshop:

* :grasscmd2:`GRASS Scripting Library <libpython/script_intro.html>`
  as entering node to Python scripting capabilities in GRASS GIS
* object-oriented (native for Python) :grasscmd2:`pyGRASS
  <libpython/pygrass_index.html>`
* spatio-temporal :grasscmd2:`GRASS GIS Temporal Framework
  <libpython/temporal_framework.html>`

:grasscmd2:`PyGRASS <libpython/pygrass_index.html>` is designed as an
**object-oriented** Python API for GRASS GIS. This is a major
difference to :grasscmd2:`GRASS Scripting Library
<libpython/script_intro.html>` which consists of procedures - Python
functions. It is important to highlight that PyGRASS is not a
replacement for GRASS Scripting Library. The both libraries are living
next to each other. It is up to a user which library will use in
his/her scripts. It's also possible to compine both libraries in one
single script (not recommended).
  
Let's do our first steps towards Python scripting in :item:`Python`
tab.

.. figure:: ../images/units/10/layer-manager-python.png
   :class: middle
           
   Interactive prompt in :item:`Python` tab.
            
Let's perform a simple computation workflow below in Python:

#. Set computation extent based on Jena city region, align
   computational region to Sentinel bands
#. Extend computation region by 1km offset
#. Set mask based on cloud vector map
#. Compute NDVI
#. Compute NDVI values statistics, print min, max and mean NDVI values

The workflow is represented by a set of GRASS commands (map names shorten):

.. code-block:: bash

   # 1.
   g.region vector=jena_boundary align=B04_10m
   # 2.
   g.region n=n+1000 s=s-1000 e=e+1000 w=w-1000             
   # 3.
   r.mask -i vector=MaskFeature
   # 4.
   i.vi red=B04_10m output=ndvi viname=ndvi nir=B08_10m             
   # 5.
   r.univar map=ndvi

.. tip:: GRASS modules run from :item:`Console` and GUI dialogs can be
   logged into file by :item:`Log file` (click to start/stop
   logging). Logged commands can be used as a starting point for your
   first Python script.

   .. figure:: ../images/units/10/layer-manager-log-file.png
               
      Log GRASS commands into file.         
            
The commands needs to be changed to satisfy Python syntax. In this
unit **GRASS Scripting Library** will be used since :item:`Python` tab
already includes this library as ``gs``. Only basic syntax will be
explained. In next units we will switch to object-oriented PyGRASS
library.

.. _python-code:

GRASS commands can be run by :grass-script:`core.run_command` function.

.. code-block:: python
                
   # 1.
   gs.run_command('g.region', vector='jena_boundary', align='L2A_T32UPB_20170706T102021_B04_10m')
   # 2.
   gs.run_command('g.region', n='n+1000', s='s-1000', e='e+1000', w='w-1000') # 3.
   gs.run_command('r.mask', flags='i', vector='MaskFeature', overwrite=True)
   # 4.
   gs.run_command('i.vi', red='L2A_T32UPB_20170706T102021_B04_10m', output='ndvi',
                     viname='ndvi', nir='L2A_T32UPB_20170706T102021_B08_10m', overwrite=True)
   # 5.
   gs.run_command('r.univar', map='ndvi')

.. tip:: Python shell has its history, previous commands can be browsed by
   :kbd:`Alt+P`, next commands by :kbd:`Alt+N`.

Output of :grasscmd:`r.univar` tool is ignored by
:grass-script:`core.run_command` function. :grasscmd:`r.univar` must
be run by :grass-script:`core.read_command` which returns an output of
the command. But it is still not perfect, statistics is printed to
standard output and cannot be processed by Python commands. It would
be feasible to retrieve command's output as Python object, a
dictionary. This can be done by:

* running :grasscmd:`r.univar` with :param:`-g` to enable shell script
  (parse-able) output
* and using :grass-script:`core.parse_command` function which parses
  output and store result as a Python dictionary object

.. code-block:: python
                
   # 5.
   stats = gs.parse_command('r.univar', flags='g', map='ndvi')
   print('NDVI min value: {0:.4f}'.format(float(stats['min'])))
   print('NDVI max value: {0:.4f}'.format(float(stats['max'])))
   print('NDVI mean value: {0:.4f}'.format(float(stats['mean'])))

.. figure:: ../images/units/10/python-result.png
   :class: middle
           
   Running Python code in :item:`Python` tab.

Resultant NDVI raster map can be displayed easily by calling
``AddLayer()`` function directly from Python shell.

.. code-block:: python

   AddLayer('ndvi')                

.. _modeler-python:
            
Graphical Modeler and Python
----------------------------

Model created in Graphical Modeler can be easily converted into Python
script. Let's open the model created in :doc:`09`: `ndvi-v3.gxm
<../_static/models/ndvi-v3.gxm>`__ and switch to :item:`Python editor`
tab.

.. figure:: ../images/units/10/model-python-editor.png
   :class: large
   
   Python editor integrated in Graphical Modeler. Python code can be
   modified, run or saved into file (:file:`ndvi-v3.py`).
